### 1、数据库事务有哪四种

```
原子性，一致性，隔离性，持久性
```

### 2、数据库与缓存数据的一致性，这个问题怎么解决的

```
原因：在高并发的系统中我们通常会使用Cache+DB的架构来加快读性能
（1）先删缓存，再更新数据库 （若更新失败，缓存与DB都无数据；并发下可能读到脏数据）
（2）先更新数据库，再删缓存（删除缓存与读缓存的并发可能造成脏读）
（3）延迟双删策略（能规避并发脏读的问题）
update DB;
delete cache;
Thread.sleep(500);
delete cache;
异步消息队列同步策略：MQ（如 Kafka、RabbitMQ）异步推送一条“数据变更消息”，由消费者删除或更新缓存
分布式锁机制
当同一条数据被并发修改时，使用 Redis 分布式锁保证同一时间只允许一个线程
在项目中我们确实遇到过数据库与缓存不一致的问题。
我们的方案是 ‘先更新数据库，再删除缓存’，这样可以保证数据最终一致。
同时，为了防止并发请求在缓存被删除后立刻把旧值写回缓存，我们采用了延迟双删策略——在更新数据库后，延迟几百毫秒再进行一次缓存删除。
对于一些高并发、对一致性要求高的模块，我们还引入了 MQ异步消息机制，让数据库更新事件自动触发缓存同步，从而进一步提高一致性和可靠性。”
那你如何保证删除缓存的原子性？”
可以用事务机制或 Redis pipeline，确保操作不被中断。
“如果删除缓存失败怎么办？”
可以用重试机制、补偿任务，或将删除操作记录到 MQ 异步重试。
```

### 3、数据库中有哪些锁

```
从范围上看有表锁，行锁
从类型上看有共享锁和排他锁
而InnoDB还实现了更细粒度的机制：比如意向锁、间隙锁和临键锁
InnoDB 主要使用行锁，能在高并发下保持性能。
行锁的实现依赖于索引，比如 SELECT ... FOR UPDATE 会对符合条件的索引记录加锁。
间隙锁和临键锁主要用于防止幻读问题；
而意向锁是用来协调表锁与行锁共存的。
```

### 4、mysql索引实现原理，为什么用b+树，同时你还需要解释一下b树

```
在MySQL的InnoDB（in no DB）引擎中，底层数据结构是 B+ 树
索引的作用是为了加快查询速度
当我们执行 SELECT * FROM user WHERE id = 1000 时，
MySQL 并不会一行行去扫描整张表（那是全表扫描）。
它会先在 索引文件（B+树结构） 中查找对应键值的位置，
再通过指针直接定位到具体数据页，从而大大提高查询效率
B树在除叶子节点外的节点也存储了数据，但是B+树只在叶子节点中存放了数据，内节点仅作为索引，包含所有数据和关键字，并用链表连接，形成有序链表
				B 树           				B+ 树             
叶子节点     	含有部分数据 		        所有数据都在叶子节点
非叶子节点  	   既存索引也存数据        	  只存索引（key），不存数据
叶子节点之间 	   无指针          		通过链表相连        
查询性能  		查询到目标可能在中间节点结束 所有查询都走到叶子节点，IO更稳定
范围查询   		不方便           			非常方便，顺着链表可直接扫描区间
相比 二叉搜索树：二叉树高度太深，但是B+树属于是多叉结构，一层能容纳多个key
MySQL InnoDB 的索引底层是 B+ 树结构。
相比 B 树，B+ 树的所有数据都存放在叶子节点，非叶子节点只保存索引，
这样能让单个节点更小、树的层数更少，从而减少磁盘IO次数。
同时叶子节点间通过链表相连，非常适合范围查询，这就是为什么 MySQL 选择使用 B+ 树。”
Q1：为什么B+树比红黑树快？

因为红黑树是二叉树，节点多、层高高，磁盘IO次数多；而B+树是多叉树，一次IO能读取更多索引。

Q2：MyISAM 与 InnoDB 索引有什么区别？
MyISAM 的主键索引和数据分开存放（非聚簇）；
InnoDB 的主键索引叶子节点直接存储整行数据（聚簇索引）。
```

### 5、什么是磁盘页

```
磁盘页是数据库与磁盘进行数据交换的最小单元
这样就解释了为什么B树没有B+树更合适了，因为在一个磁盘页中对于B+树来说只需要存储索引和指针，但是对于B树来说不仅需要存储索引和指针还需要存储数据，这样一对比那么B树在一个磁盘页中存储的索引就少了，那么他就需要更多的磁盘I/O，这样说明了他的速度更慢
```

### 6、行锁是怎么实现的

```
InnoDB 的行锁是通过给索引上的记录加锁实现的，若这个表没有索引，则行锁将退化为表锁
InnoDB 的锁信息存储在锁表（Lock Table）结构中，并保存在内存里
找到符合条件的索引记录；
在该索引记录上添加对应的锁结构；
直到事务提交或回滚时再释放锁。
事务（原子性，隔离性，一致性，持久性）
```

### 7、幻读是什么，与之相关的有什么

```
幻读是在同一个事务中，前后两次执行相同的查询语句，结果集的记录条数发生了变化
还有脏读，不可重复读
并发问题               			含义                   			示例     
脏读（Dirty Read）     			读到别人未提交的数据  		事务 B 改了数据但没提交，事务 A 读到了 
不可重复读（Non-repeatable Read）同一事务内两次读取同一行，值不同     事务 B 修改了某行并提交         
幻读（Phantom Read）          	同一事务内两次读取的行数不同   	  事务 B 插入或删除了新行        
“可以这么理解：脏读和不可重复读都是数据值变了，而幻读是数据数量变了。
脏读是读到了别人还没提交的数据；
不可重复读是同一事务中两次读取同一行，值不一样；
幻读是同一事务中两次查询，结果集的行数变了，比如多出了一条。
在 MySQL 的 InnoDB 引擎里，默认的 REPEATABLE READ 级别通过 MVCC 和临键锁机制，可以防止这些问题，包括幻读。”
```

### 8、 REPEATABLE READ 是什么意思

```
REPEATABLE READ = 一次事务，一个快照；多次读取结果一致。
MySQL InnoDB 用 MVCC + 临键锁 同时解决了不可重复读和幻读问题
```

